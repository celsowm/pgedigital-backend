# Hydration & Entities

MetalORM offers two ways to go from SQL rows to richer structures:

1. **Hydration only** – `hydrateRows(rows, plan)` → nested plain objects.
2. **Entity runtime** – `builder.execute(session)` → entities with lazy relations via an `OrmSession`.

## 1. Hydrating with `hydrateRows`

The `hydrateRows()` function takes an array of database rows and a hydration plan to produce nested objects. The hydration plan is generated by the `SelectQueryBuilder` when you use the `include()` method.

```typescript
const builder = new SelectQueryBuilder(users)
  .selectRaw('*')
  .include('posts', {
    columns: ['id', 'title', 'content'],
  });

const { sql, params } = builder.compile(new MySqlDialect());
const rows = await db.execute(sql, params);

// Automatically hydrates to:
// {
//   id: 1,
//   name: 'John',
//   posts: [
//     {
//       id: 1,
//       title: 'First Post',
//       comments: [...]
//     }
//   ]
// }
const hydrated = hydrateRows(rows, builder.getHydrationPlan());
```

## How it Works

The `SelectQueryBuilder` analyzes the `include()` configuration and generates a `HydrationPlan`. This plan contains the necessary information to map the flat rows to a nested structure, including relation details and column aliases. The `hydrateRows()` function then uses this plan to efficiently process the result set.

> ℹ️ **Set operations are not hydrated.**  
> When a query includes `union` / `unionAll` / `intersect` / `except`, the builder skips hydration metadata. Calling `.execute(session)` on those queries returns one entity proxy per row (not tracked in the identity map) so duplicates from `UNION ALL` are preserved and no relation nesting is attempted.

## Pagination and 1:N includes

- MetalORM now rewrites paginated eager has-many / belongs-to-many queries so `LIMIT/OFFSET` apply to distinct parent rows. It hoists the joined query into a CTE, selects the ordered parent ids with your limit, then joins back to the full result set — still one SQL statement.
- The rewrite kicks in when the ordering uses root-table columns. If you order by child-table columns the builder keeps the original query, because those child values can still fragment pages.
- Lazy includes remain a good option when you want to paginate by parents but keep child filters or ordering: page the parents, then let the lazy loader fetch children for that page in one batched query.

## Pivot Column Hydration

For belongs-to-many relationships, you can request pivot columns via the `pivot` option. Pivot columns are hydrated alongside each child row under the `_pivot` key:

```typescript
.include('projects', {
  columns: ['id', 'name', 'client'],
  pivot: { columns: ['assigned_at', 'role_id'] }
})
```

This would hydrate to:

```typescript
{
  id: 1,
  name: 'John Doe',
  projects: [
    {
      id: 101,
      name: 'Project Alpha',
      client: 'Acme Corp',
      _pivot: {
        assigned_at: '2023-01-15T10:00:00.000Z',
        role_id: 2
      }
    }
  ]
}
```

### Advanced Hydration Options

You can also specify which pivot columns to include and customize the hydration:

```typescript
.include('projects', {
  columns: ['id', 'name'],
  pivot: {
    columns: ['assigned_at', 'role_id'],
    alias: 'assignment_info' // Custom alias instead of '_pivot'
  },
})

## 2. Entities on top of hydration

Pass an `OrmSession` (see [Getting Started](getting-started.md#4-a-taste-of-the-runtime-optional)) to `.execute(session)` so MetalORM can hydrate rows and track entity state.

- MetalORM compiles and executes the query using the dialect attached to your `OrmSession`.
- If a `HydrationPlan` exists, it is applied.
- Each root row is wrapped in an entity proxy:
  - scalar fields behave like normal properties
  - relation properties expose `HasManyCollection`, `BelongsToReference`, or `ManyToManyCollection`.
  - relation wrappers are JSON-safe (`toJSON` + hidden internals), so `JSON.stringify` a hydrated entity will emit its nested data without circular reference errors.

```ts
const [user] = await new SelectQueryBuilder(users)
  .select({ id: users.columns.id, name: users.columns.name })
  .include('posts', { columns: ['id', 'title'] }) // eager
  .includeLazy('roles')                            // lazy (e.g. a BelongsToMany relation)
  .execute(session);

const eagerPosts = user.posts.getItems();  // hydrated from the join
const lazyRoles = await user.roles.load(); // resolved on demand
```
```
