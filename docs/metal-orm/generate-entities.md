# Generating Entities from an Existing Database

If you already ran `npm install metal-orm`, the helper script at `scripts/generate-entities.mjs` ships inside the package. Run it from your app (or wire it into an npm script) so MetalORM can introspect a live database and emit decorator-based entity classes that match your current schema.

Prefer the bundled CLI alias (requires Node 18+):

```bash
npx metal-orm-gen -- \
  --dialect=postgres \
  --url=postgres://user:pass@host/db \
  --schema=public \
  --out=src/entities.ts
```

Split the output into one file per entity and an `index.ts` barrel by pointing `--out-dir` at a directory (the helper file defaults to `index.ts` inside that directory):

```bash
npx metal-orm-gen -- \
  --dialect=postgres \
  --url=postgres://user:pass@host/db \
  --schema=public \
  --out-dir=src/entities
```

## Run the script

Call the bundled helper through the npm alias (it forwards to `scripts/generate-entities.mjs`):

```bash
npm run gen:entities -- \
  --dialect=postgres \
  --url=postgres://user:pass@host/db \
  --schema=public \
  --out=src/entities.ts
```

Pass `--out-dir=./src/entities` instead of `--out` to spill each table into its own file plus an autogenerated `index.ts` that re-exports every class and keeps `bootstrapEntityTables`/`allTables` available.

If you prefer, set `DATABASE_URL` (or the dialect-appropriate env var) and omit `--url`:

```bash
DATABASE_URL=postgres://user:pass@host/db \
  npm run gen:entities -- \
  --dialect=postgres \
  --schema=public \
  --out=src/entities.ts
```

If you prefer to invoke the script directly, point Node at the shipped file:

```bash
node ./node_modules/metal-orm/scripts/generate-entities.mjs \
  --dialect=postgres \
  --url=postgres://user:pass@host/db \
  --schema=public \
  --out=src/entities.ts
```

The script:

1. Loads the dialect-specific driver that you already installed alongside `metal-orm`.
2. Connects to your database and runs `introspectSchema` from `metal-orm/dist`.
3. Emits an entity file that imports `col`, decorator helpers, and the `HasManyCollection` / `ManyToManyCollection` helpers.

The default output is `generated-entities.ts` in your current working directory, but you can override it via `--out=path/to/file.ts`.

## Key flags

| Flag | Meaning |
| --- | --- |
| `--dialect=(postgres|mysql|sqlite|mssql)` | Choose the driver. Defaults to `postgres`. |
| `--url=<connection>` | Connection string for Postgres, MySQL/MariaDB, or SQL Server. Required unless you point at SQLite. |
| `--db=<path>` | SQLite file path (defaults to `:memory:` when you omit this flag). |
| `--schema=<name>` | Schema (or catalog) to introspect. |
| `--include=tbl1,tbl2` | Whitelist tables to emit. |
| `--exclude=tbl3,tbl4` | Skip specific tables. |
| `--locale=pt-BR` | Naming locale for class and relation names (default: `en`). |
| `--naming-overrides=path/to/file.json` | JSON map of irregular plurals to merge into the locale strategy. |
| `--out=<file>` | Where to dump the generated code (default: `generated-entities.ts`; used for the shared index when `--out-dir` is supplied). |
| `--out-dir=<dir>` | Emit one file per entity inside this directory and generate an `index.ts` (or whatever `--out` points to) that re-exports each class plus the helper functions. |
| `--dry-run` | Print the generated source to stdout instead of writing a file. |
| `--help` | Show the usage text inside the script. |

You can also rely on the `DATABASE_URL` environment variable instead of `--url`.

## Output notes

The generated file:

- Converts every table into an `@Entity()` class whose name is derived from the table name (singularized + PascalCase).
- Decorates columns with `@Column` or `@PrimaryKey`, applies `col.xxx()` helpers, marks nullability, defines defaults, and wires up foreign keys.
- Adds relations automatically: `@BelongsTo`, `@HasOne` (when the FK is unique/1:1), `@HasMany`, and `@BelongsToMany` decorators that point at the other generated classes.
- Infers foreign keys/index metadata from each supported dialect so the generated decorators can emit `col.references`/`@BelongsTo`/`@HasMany` (even across schemas) without extra wiring.
- Detects boolean-friendly types like `tinyint(1)`/`bit` and surfaces them as `col.boolean()` instead of `col.int()`, keeping defaults such as `((1))` intact.
- Exports `bootstrapEntityTables()` so you can bootstrap and reuse the same table definitions when wiring up repositories right after `bootstrapEntities()`.
- Adds `allTables()` as a convenience wrapper around `bootstrapEntities()`.
- Splits output into per-entity files plus a shared index when you provide `--out-dir`; the index file defaults to the directory's `index.ts` (or whatever `--out` points to) and still re-exports the classes along with `bootstrapEntityTables()`/`allTables()`, while `--dry-run` will print every generated segment instead of writing files.
- Converts persisted table/column comments from each dialect (Postgres `COMMENT ON`, MySQL/MariaDB `COMMENT`, SQL Server `MS_Description`, SQLite `schema_comments`) into JSDoc that sits above the generated decorators.
- Adds `@defaultValue` and `@remarks` tags when column defaults, auto-increment identity, check constraints, or foreign key metadata exist so IDE hovers surface the database intent.

The script also preserves the real table name when it cannot be derived from the class name by passing `tableName` to `@Entity()`.

If your project sets `moduleResolution` to `node16`/`nodenext`, the generator will read your `tsconfig` and automatically append `.js` to the relative imports between the split files so the emitted source satisfies the Node/TS requirement for explicit extensions.

## Comment metadata

When `generate-entities` runs, it now emits every introspected table/column comment (`DatabaseTable.comment` / `DatabaseColumn.comment`) as a JSDoc block above the generated class/field so your descriptions and tooltips stay in sync with the database.

| Dialect | Where the comment comes from |
| --- | --- |
| Postgres | `COMMENT ON TABLE` / `COMMENT ON COLUMN` |
| MySQL/MariaDB | `COMMENT` clause on tables/columns |
| SQL Server | `MS_Description` extended property |
| SQLite | Optional `schema_comments` metadata table |

For SQLite you can store descriptions yourself before running the generator:

```sql
CREATE TABLE IF NOT EXISTS schema_comments (
  object_type TEXT CHECK(object_type IN ('table','column')) NOT NULL,
  schema_name TEXT,
  table_name TEXT NOT NULL,
  column_name TEXT,
  comment TEXT NOT NULL,
  PRIMARY KEY (object_type, schema_name, table_name, column_name)
);

INSERT INTO schema_comments (object_type, table_name, comment) VALUES
('table', 'accounts', 'Contas do sistema');

INSERT INTO schema_comments (object_type, table_name, column_name, comment) VALUES
('column', 'accounts', 'id', 'Identificador da conta');
```

The generator will now render these descriptions as part of the generated sources.

## Split output

Point `--out-dir` at a directory to emit each table as its own `EntityName.ts` file while still producing a shared index file (defaults to the directory's `index.ts`, but you can override it via `--out`) that imports/re-exports the classes and exposes `bootstrapEntityTables()`/`allTables()`. Combine `--dry-run` with `--out-dir` to preview all generated files without touching disk.

## Naming locale and irregulars

The generator now supports locale-aware pluralization for class names and relation properties:

```bash
# Portuguese pluralization (estado_solicitacao -> estadosSolicitacao)
npm run gen:entities -- --locale=pt-BR --schema=public --out=src/entities.ts

# Merge project-specific irregulars
npm run gen:entities -- \
  --locale=pt-BR \
  --naming-overrides=./naming-irregulars.json \
  --schema=public \
  --out=src/entities.ts
```

`--naming-overrides` expects a JSON object mapping singular to plural. You can wrap it in an `irregulars` object or pass the map directly:

```json
{
  "irregulars": {
    "solicitacao": "solicitacoes",
    "mao": "maos"
  }
}
```

Portuguese includes a few common irregulars out of the box (`mao → maos`, `pao → paes`, `cao → caes`, `mal → males`, `consul → consules`). Add your own irregulars for domain terms to avoid surprises; for example map `irmao` to `irmaos` or `pais` to `paises` if your schema uses those singular forms.

If you omit `--locale`, the generator defaults to English rules.

## Extending locales

Locale inflection rules live under `scripts/inflection` (word plural/singular plus optional relation-property pluralization). To add a new language:

1. Create a new module like `scripts/inflection/es.mjs` that exports a `createXInflector()` with `pluralizeWord`/`singularizeWord` (and optionally `pluralizeRelationProperty`).
2. Register it in `scripts/inflection/index.mjs` via `registerInflector('es', createXInflector)`.
3. Run the generator with `--locale=es` (or `es-ES`).

## Dialect drivers

`generate-entities.mjs` dynamically imports the driver for the dialect you select. Install the peer dependency that corresponds to your database:

- PostgreSQL: `npm install pg`
- MySQL/MariaDB: `npm install mysql2`
- SQLite: `npm install sqlite3`
- SQL Server: `npm install tedious`

If you try to introspect without the driver, the script throws at startup because the dynamic `import` fails.

## Helpful tips

- Put the command behind an npm script if you run it often.
- Use `--include`/`--exclude` to keep generated files tidy instead of editing them manually.
- Commit the generated file and rerun the script after every schema change, like the autogenerated comment warns (`// Regenerate after schema changes.`).
- If you get a `Missing connection string` error, double-check that `DATABASE_URL` is set or that `--url` is correct.
